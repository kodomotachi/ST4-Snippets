<snippet>
	<content><![CDATA[
template<typename T> struct SegTree {$0
	int n; vector<T> t;
	SegTree(int n) : n(n) { t.resize(2*n); }
	T &operator[](int idx) { return t[idx + n]; }
	T merge(T a, T b) { return a + b; }
	// initializing Segment Tree

	void update() {
		// update the whole tree -> O(n)

		for (int i = n - 1; !!i; i--)
			t[i] = merge(t[i << 1], t[i << 1 | 1]);
	}
	
	void modify(int a, int b, i64 c = FIXED_RANDOM) {
		// 2 parameters passed -> single   modification -> O(logn)
		// 3 parameters passed -> interval modification -> O(logn)

		if (c == FIXED_RANDOM) {
			for (t[a += n] = b; a >>= 1; )
				t[a] = merge(t[a << 1], t[a << 1 | 1]);
		} else {
			int l = a + n, r = b + n + 1;
			for (; l < r; l >>= 1, r >>= 1) {
				if (l & 1) t[l] = merge(t[l], c), l++;
				if (r & 1) --r, t[r] = merge(c, t[r]);
			}
		}
	}
	
	T getVal(int a = -1, int b = -1) {
		// 1 parameter  passed -> single   access -> O(logn)
		// 2 parameters passed -> interval access -> O(logn)

		if (b == -1) {
			T res = 0;
			for (a += n; !!a; a >>= 1)
				res = merge(res, t[a]);
			return res;
		} else {
			T resL = 0, resR = 0;
			int l = a + n, r = b + n + 1;
			for (; l < r; l >>= 1, r >>= 1) {
				if (l & 1) resL = merge(resL, t[l++]);
				if (r & 1) resR = merge(t[--r], resR);
			} return merge(resL, resR);
		}
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>SegTreeDS</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
